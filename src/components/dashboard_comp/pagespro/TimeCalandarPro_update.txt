import { useState, useEffect, useContext, useCallback } from 'react';
import { AuthContext } from "../../../context/AuthContext";

const TimeCalandarPro = () => {
    const { token } = useContext(AuthContext);
    const jours = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];

    const [horaires, setHoraires] = useState({
        Lundi: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
        Mardi: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
        Mercredi: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
        Jeudi: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
        Vendredi: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
        Samedi: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
        Dimanche: { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false },
    });

    const fetchHoraires = useCallback(async () => {
        const professionalId = 7; // Remplacez par l'ID professionnel approprié
        try {
            console.log('Fetching horaires...');
            const response = await fetch(`http://127.0.0.1:8000/api/availability/${professionalId}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`,
                },
            });

            if (!response.ok) {
                throw new Error('Erreur de réponse de l\'API');
            }

            let data = await response.json();
            console.log('Données récupérées:', data); // Déboguer ici pour voir la structure des données

            // Convertir en tableau si ce n'est pas déjà un tableau
            if (!Array.isArray(data)) {
                console.warn('Les données ne sont pas un tableau. Conversion en tableau...');
                data = [data];
            }

            console.log('Données après conversion en tableau:', data);

            const mappedHoraires = {};
            data.forEach(horaire => {
                console.log('Horaire:', horaire); // Déboguer chaque horaire

                const jourFr = {
                    Monday: 'Lundi',
                    Tuesday: 'Mardi',
                    Wednesday: 'Mercredi',
                    Thursday: 'Jeudi',
                    Friday: 'Vendredi',
                    Saturday: 'Samedi',
                    Sunday: 'Dimanche',
                }[horaire.day];

                if (!jourFr) {
                    console.warn('Jour non mappé:', horaire.day);
                    return;
                }

                if (!mappedHoraires[jourFr]) {
                    mappedHoraires[jourFr] = { matin: { debut: '', fin: '' }, apresMidi: { debut: '', fin: '' }, ferme: false };
                }

                // Déterminer la période de la journée (matin ou après-midi)
                const timeOfDay = horaire.start_time < '12:00:00' ? 'matin' : 'apresMidi';
                mappedHoraires[jourFr][timeOfDay] = { debut: horaire.start_time, fin: horaire.end_time };

                console.log(`Horaires mappés pour ${jourFr}:`, mappedHoraires[jourFr]);
            });

            console.log('Horaires mappés:', mappedHoraires);

            setHoraires(prevHoraires => ({
                ...prevHoraires,
                ...mappedHoraires
            }));
        } catch (error) {
            console.error('Erreur lors de la récupération des horaires:', error);
        }
    }, [token]);

    const updateHoraires = async () => {
        const professionalId = 7; // Remplacez par l'ID professionnel approprié

        for (const jour of jours) {
            if (!horaires[jour].ferme) {
                const dayMapping = {
                    Lundi: 'Monday',
                    Mardi: 'Tuesday',
                    Mercredi: 'Wednesday',
                    Jeudi: 'Thursday',
                    Vendredi: 'Friday',
                    Samedi: 'Saturday',
                    Dimanche: 'Sunday',
                };

                const requestData = [
                    {
                        day: dayMapping[jour],
                        start_time: horaires[jour].matin.debut,
                        end_time: horaires[jour].matin.fin,
                        professional_id: professionalId,
                    },
                    {
                        day: dayMapping[jour],
                        start_time: horaires[jour].apresMidi.debut,
                        end_time: horaires[jour].apresMidi.fin,
                        professional_id: professionalId,
                    },
                ];

                console.log('Données de requête pour mise à jour:', requestData);

                try {
                    for (const data of requestData) {
                        if (data.start_time && data.end_time) {
                            const response = await fetch(`http://127.0.0.1:8000/api/availability/${professionalId}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${token}`,
                                },
                                body: JSON.stringify(data),
                            });

                            if (!response.ok) {
                                throw new Error(`Erreur lors de la mise à jour des données pour ${jour}: ${response.statusText}`);
                            }

                            const result = await response.json();
                            console.log(`Données mises à jour pour ${jour}:`, result);
                        }
                    }
                } catch (error) {
                    console.error('Erreur lors de la mise à jour des horaires:', error);
                }
            }
        }
    };

    const handleSubmit = async () => {
        console.log('Soumettre les horaires...');
        await updateHoraires();
    };

    useEffect(() => {
        console.log('Effet de récupération des horaires déclenché');
        fetchHoraires();
    }, [fetchHoraires]);

    const handleHoraireChange = (jour, periode, type, valeur) => {
        console.log(`Modification des horaires pour ${jour} ${periode} ${type}: ${valeur}`);
        setHoraires(prevHoraires => ({
            ...prevHoraires,
            [jour]: {
                ...prevHoraires[jour],
                [periode]: {
                    ...prevHoraires[jour][periode],
                    [type]: valeur,
                },
            },
        }));
    };

    const handleFermeChange = (jour, valeur) => {
        console.log(`Modification de l'état fermé pour ${jour}: ${valeur}`);
        setHoraires(prevHoraires => ({
            ...prevHoraires,
            [jour]: {
                ...prevHoraires[jour],
                ferme: valeur,
            },
        }));
    };

    return (
        <div>
            {jours.map((jour) => (
                <div key={jour} className="mb-4">
                    <label>
                        <input
                            type="checkbox"
                            checked={horaires[jour].ferme}
                            onChange={(e) => handleFermeChange(jour, e.target.checked)}
                        />
                        {` ${jour} : Fermé`}
                    </label>
                    {!horaires[jour].ferme && (
                        <div>
                            <div>
                                <label>Matin:</label>
                                <input
                                    type="time"
                                    value={horaires[jour].matin.debut}
                                    onChange={(e) => handleHoraireChange(jour, 'matin', 'debut', e.target.value)}
                                    className="w-full p-1 border rounded mb-2"
                                />
                                <input
                                    type="time"
                                    value={horaires[jour].matin.fin}
                                    onChange={(e) => handleHoraireChange(jour, 'matin', 'fin', e.target.value)}
                                    className="w-full p-1 border rounded mb-2"
                                />
                            </div>
                            <div>
                                <label>Après-midi:</label>
                                <input
                                    type="time"
                                    value={horaires[jour].apresMidi.debut}
                                    onChange={(e) => handleHoraireChange(jour, 'apresMidi', 'debut', e.target.value)}
                                    className="w-full p-1 border rounded mb-2"
                                />
                                <input
                                    type="time"
                                    value={horaires[jour].apresMidi.fin}
                                    onChange={(e) => handleHoraireChange(jour, 'apresMidi', 'fin', e.target.value)}
                                    className="w-full p-1 border rounded mb-2"
                                />
                            </div>
                        </div>
                    )}
                </div>
            ))}
            <button onClick={handleSubmit}>Soumettre</button>
        </div>
    );
};

export default TimeCalandarPro;
